package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/a-company-jp/gaishi-hackathon-app/backend/graph/model"
	"github.com/a-company-jp/gaishi-hackathon-app/backend/middleware"
	"github.com/google/uuid"
)

// JoinTableSession is the resolver for the joinTableSession field.
func (r *mutationResolver) JoinTableSession(ctx context.Context, tableUUID string) (*model.TableSessionUser, error) {
	auuid := uuid.MustParse(ctx.Value(middleware.CTX_ACCOUNT_UUID).(string))

	tuuid, err := uuid.Parse(tableUUID)
	if err != nil {
		return nil, fmt.Errorf("invalid table uuid")
	}

	tab, err := r.PostgresSvc.GetTableByUUID(tuuid)
	if err != nil {
		return nil, err
	}

	tableSession, err := r.PostgresSvc.GetActiveTableSessionByTableID(tab.ID)
	if err == nil {
		// 既存のセッションに参加
		session, err := r.PostgresSvc.JoinTableSession(tableSession.ID, auuid)
		if err != nil {
			return nil, err
		}

		users, err := r.PostgresSvc.ListAccountsByTableSessionID(tableSession.ID)
		if err != nil {
			return nil, err
		}
		return &model.TableSessionUser{
			TableSession: &model.TableSession{
				ID:          strconv.Itoa(session.ID),
				Table:       nil,
				StartTime:   session.CreatedAt.Time.String(),
				EndTime:     nil,
				TotalUsers:  len(users),
				Cart:        nil,
				PlacedOrder: nil,
				IsActive:    false,
			},
			UserNumber: session.UserNumber,
			Allergies:  nil,
		}, nil
	}
	newTableSession, err := r.PostgresSvc.CreateTableSession(tuuid)
	if err != nil {
		return nil, fmt.Errorf("failed to create table session")
	}
	_, err = r.PostgresSvc.JoinTableSession(newTableSession.ID, auuid)
	if err != nil {
		return nil, err
	}
	return &model.TableSessionUser{
		TableSession: &model.TableSession{
			ID:         strconv.Itoa(newTableSession.ID),
			Table:      nil,
			StartTime:  newTableSession.CreatedAt.Time.String(),
			EndTime:    nil,
			TotalUsers: 0,
			Cart:       nil,
		},
	}, nil
}

// CompleteTableSession is the resolver for the completeTableSession field.
func (r *mutationResolver) CompleteTableSession(ctx context.Context, tableSessionID string, sessionUserID string) (*bool, error) {
	panic(fmt.Errorf("not implemented: CompleteTableSession - completeTableSession"))
}

// SetUserAllergies is the resolver for the setUserAllergies field.
func (r *mutationResolver) SetUserAllergies(ctx context.Context, allergenIds []string) (*model.TableSessionUser, error) {
	panic(fmt.Errorf("not implemented: SetUserAllergies - setUserAllergies"))
}

// AddItemToCart is the resolver for the addItemToCart field.
func (r *mutationResolver) AddItemToCart(ctx context.Context, orderID string, menuItemID string, quantity int) (*model.Cart, error) {
	panic(fmt.Errorf("not implemented: AddItemToCart - addItemToCart"))
}

// RemoveItemFromCart is the resolver for the removeItemFromCart field.
func (r *mutationResolver) RemoveItemFromCart(ctx context.Context, orderID string, orderItemID string) (*model.Cart, error) {
	panic(fmt.Errorf("not implemented: RemoveItemFromCart - removeItemFromCart"))
}

// PlaceOrder is the resolver for the placeOrder field.
func (r *mutationResolver) PlaceOrder(ctx context.Context, orderID string) (*bool, error) {
	panic(fmt.Errorf("not implemented: PlaceOrder - placeOrder"))
}

// MyCuuid is the resolver for the myCUUID field.
func (r *queryResolver) MyCuuid(ctx context.Context) (string, error) {
	v := ctx.Value(middleware.CTX_COOKIE_UUID)
	if v == nil {
		return "", fmt.Errorf("no cookie found")
	}
	cuuid, ok := v.(string)
	if !ok {
		return "", fmt.Errorf("invalid cookie value")
	}
	return cuuid, nil
}

// HealthCheck is the resolver for the healthCheck field.
func (r *queryResolver) HealthCheck(ctx context.Context) (*string, error) {
	now := time.Now()
	out := fmt.Sprintf(
		"hi there!! you got request from server at %s",
		now.Format("2006-01-02 15:04:05"),
	)
	return &out, nil
}

// Restaurant is the resolver for the restaurant field.
func (r *queryResolver) Restaurant(ctx context.Context) (*model.Restaurant, error) {
	restID := ctx.Value(middleware.CTX_RESTAURANT_ID).(int)
	restaurant, err := r.PostgresSvc.GetRestaurant(restID)
	if err != nil {
		return nil, err
	}
	var addr, phone *string
	if restaurant.Address.Valid {
		addr = &restaurant.Address.String
	}
	if restaurant.PhoneNumber.Valid {
		phone = &restaurant.PhoneNumber.String
	}
	return &model.Restaurant{
		Name:        restaurant.Name,
		Address:     addr,
		PhoneNumber: phone,
		//	MenuCategories: restaurant.
		//	MenuItems:      nil,
	}, nil
}

// TableSession is the resolver for the tableSession field.
func (r *queryResolver) TableSession(ctx context.Context) (*model.TableSession, error) {
	panic(fmt.Errorf("not implemented: TableSession - tableSession"))
}

// MenuItems is the resolver for the menuItems field.
func (r *queryResolver) MenuItems(ctx context.Context, lang *string) ([]*model.MenuItem, error) {
	restID := ctx.Value(middleware.CTX_RESTAURANT_ID).(int)
	rest, err := r.PostgresSvc.GetRestaurant(restID)
	if err != nil {
		return nil, fmt.Errorf("failed to get restaurant, %w", err)
	}
	items, err := r.PostgresSvc.GetMenuItems(rest.ID, "ja")
	if err != nil {
		return nil, err
	}
	return items, nil
}

// MenuItemsByCategory is the resolver for the menuItemsByCategory field.
func (r *queryResolver) MenuItemsByCategory(ctx context.Context, lang *string, categoryID string) ([]*model.MenuItem, error) {
	panic(fmt.Errorf("not implemented: MenuItemsByCategory - menuItemsByCategory"))
}

// MenuCategories is the resolver for the menuCategories field.
func (r *queryResolver) MenuCategories(ctx context.Context, lang *string, restaurantID string) ([]*model.MenuCategory, error) {
	restID := ctx.Value(middleware.CTX_RESTAURANT_ID).(int)
	categories, err := r.PostgresSvc.GetMenuCategories(restID)
	if err != nil {
		return nil, err
	}
	return categories, nil
}

// Allergens is the resolver for the allergens field.
func (r *queryResolver) Allergens(ctx context.Context, lang *string) ([]*model.Allergen, error) {
	allergens, err := r.PostgresSvc.GetAllAllergens("ja")
	if err != nil {
		return nil, err
	}
	return allergens, nil
}

// Cart is the resolver for the cart field.
func (r *queryResolver) Cart(ctx context.Context, lang *string) (*model.Cart, error) {
	panic(fmt.Errorf("not implemented: Cart - cart"))
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, lang *string) (*model.OrderedItem, error) {
	panic(fmt.Errorf("not implemented: Order - order"))
}

// CartUpdated is the resolver for the cartUpdated field.
func (r *subscriptionResolver) CartUpdated(ctx context.Context) (<-chan *model.Cart, error) {
	panic(fmt.Errorf("not implemented: CartUpdated - cartUpdated"))
}

// OrderUpdated is the resolver for the orderUpdated field.
func (r *subscriptionResolver) OrderUpdated(ctx context.Context) (<-chan *model.OrderedItem, error) {
	panic(fmt.Errorf("not implemented: OrderUpdated - orderUpdated"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
